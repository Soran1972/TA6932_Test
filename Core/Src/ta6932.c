#include "ta6932.h"

// SPI handle generated by CubeMX for SPI1 (adjust if you use another instance)
extern SPI_HandleTypeDef hspi1;

// === Low-level ===
static inline void TA_STB(int v){
  HAL_GPIO_WritePin(TA_STB_PORT, TA_STB_PIN, v ? GPIO_PIN_SET : GPIO_PIN_RESET);
}

static HAL_StatusTypeDef TA_sendByte(uint8_t b){
  return HAL_SPI_Transmit(&hspi1, &b, 1, 10);
}

static void TA_cmd(uint8_t cmd){
  TA_STB(0);
  TA_sendByte(cmd);
  TA_STB(1);
}

static void TA_writeSeq(uint8_t startAddr, const uint8_t *data, uint8_t len){
  TA_cmd(0x40); // Data set: write, auto-increment
  TA_STB(0);
  uint8_t a = 0xC0 | (startAddr & 0x0F);
  TA_sendByte(a);
  for(uint8_t i=0;i<len && i<16;i++) TA_sendByte(data[i]);
  TA_STB(1);
}

// === Display control ===
void TA6932_SetBrightness(uint8_t level){  // 0..7
  if(level > 7) level = 7;
  TA_cmd(0x88 | level);  // Display ON + brightness
}
void TA6932_DisplayOn(void){ TA6932_SetBrightness(7); }
void TA6932_DisplayOff(void){ TA_cmd(0x80); } // display OFF

// === Font map (Common-Cathode; bit7=dp) ===
static const uint8_t SEG_FONT[12] = {
  0x3F,0x21,0x5D,0x75,0x63,0x76,0x7E,0x25,0x7F,0x77, 0x00,0x40
};

static uint8_t g_buf[16];

static inline void putRaw(uint8_t addr, uint8_t v){ g_buf[addr & 0x0F] = v; }
static inline void putDigit(uint8_t addr, int d, int dp){
  uint8_t v = (d>=0 && d<=9)? SEG_FONT[d] : SEG_FONT[10];
  if(dp) v |= 0x80;
  putRaw(addr, v);
}

// === Public API ===
void TA6932_Init(void){
  TA_STB(1);                 // idle high
  TA6932_SetBrightness(7);   // ON + full brightness
}

void TA6932_WriteAll(void){
  TA_writeSeq(0x00, g_buf, 16);
}

void TA6932_TestPattern(void){
  // HH:MM = 12:34
  putDigit(0x00,1,0); putDigit(0x01,2,0);
  putDigit(0x02,3,0); putDigit(0x03,4,0);
  // SS = 56
  putDigit(0x04,5,0); putDigit(0x05,6,0);
  // YYYY = 2025
  putDigit(0x06,2,0); putDigit(0x07,0,0);
  putDigit(0x08,2,0); putDigit(0x09,5,0);
  // MM = 09
  putDigit(0x0A,0,0); putDigit(0x0B,9,0);
  // DD = 22
  putDigit(0x0C,2,0); putDigit(0x0D,2,0);
  // D15 colon (use dp)
  putRaw(0x0E,0x80);
  // D16 weekday off
  putRaw(0x0F,0x00);
  TA6932_WriteAll();
}

void TA6932_CounterDemo(void){
  for(int d=0; d<10; d++){
    for(int addr=0; addr<14; addr++){
      putDigit(addr, d, 0);
    }
    putRaw(0x0E, 0x80); // colon ON
    putRaw(0x0F, 0x00); // weekday off
    TA6932_WriteAll();
    HAL_Delay(1000);
  }
}


// ==== Public buffer helpers ====
void TA6932_putRaw(uint8_t addr, uint8_t v){ putRaw(addr, v); }

void TA6932_putDigit(uint8_t addr, int d, int dp){
  uint8_t v = (d>=0 && d<=9)? SEG_FONT[d] : SEG_FONT[10]; // fallback blank
  if(dp) v |= 0x80;
  putRaw(addr, v);
}

// minimal char support: digits, '-', space; others blank
void TA6932_putChar(uint8_t addr, char ch, int dp){
  uint8_t v = 0x00;
  if(ch >= '0' && ch <= '9') v = SEG_FONT[(uint8_t)(ch - '0')];
  else if(ch == '-') v = SEG_FONT[11];
  else if(ch == ' ') v = 0x00;
  if(dp) v |= 0x80;
  putRaw(addr, v);
}

// Clear whole display buffer and send
void TA6932_Clear(void){
  for (int i=0;i<16;i++) g_buf[i] = 0x00;
  TA6932_WriteAll();
}

// ==== Single-digit direct write (fixed address) ====
void TA6932_WriteOneRaw(uint8_t addr, uint8_t value){
  // fixed address write
  TA_cmd(0x44);
  TA_STB(0);
  uint8_t a = 0xC0 | (addr & 0x0F);
  TA_sendByte(a);
  TA_sendByte(value);
  TA_STB(1);
  // keep back buffer in sync
  putRaw(addr, value);
}

void TA6932_putDigitOne(uint8_t addr, int d, int dp){
  uint8_t v = (d>=0 && d<=9)? SEG_FONT[d] : SEG_FONT[10];
  if(dp) v |= 0x80;
  TA6932_WriteOneRaw(addr, v);
}

void TA6932_putCharOne(uint8_t addr, char ch, int dp){
  uint8_t v = 0x00;
  if(ch >= '0' && ch <= '9') v = SEG_FONT[(uint8_t)(ch - '0')];
  else if(ch == '-') v = SEG_FONT[11];
  else if(ch == ' ') v = 0x00;
  if(dp) v |= 0x80;
  TA6932_WriteOneRaw(addr, v);
}

